<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Gra 3D z PointerLockControls</title>
  <!-- Dołącz Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Dołącz PointerLockControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
    }
    #game-container {
      width: 100%;
      height: 100vh;
      position: relative;
    }
    /* Prosty HUD – przykładowo wyświetlenie punktów */
    #hud {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-size: 20px;
      z-index: 10;
    }
    /* Instrukcja aktywacji PointerLock */
    #blocker {
      position: absolute;
      width: 100%;
      height: 100vh;
      background-color: rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      color: #fff;
      font-size: 24px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Kontener gry -->
  <div id="game-container">
    <div id="hud">Punkty: 0</div>
    <!-- Blokada – kliknij, aby rozpocząć -->
    <div id="blocker">Kliknij, aby rozpocząć grę</div>
  </div>
  
  <script>
    // Główne zmienne
    let scene, camera, renderer, controls;
    let blocker = document.getElementById('blocker');
    let hud = document.getElementById('hud');
    let clock = new THREE.Clock();
    
    // Sterowanie – obiekt przechowujący stan klawiszy
    const move = { forward: false, backward: false, left: false, right: false };
    let sprint = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    
    // Zmienne sterujące ruchem gracza
    const baseSpeed = 20; // bazowa prędkość
    const sprintMultiplier = 2; // mnożnik przy sprintowaniu
    
    // Inicjalizacja sceny
    function initGame() {
      // Scena
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      
      // Kamera – pozycjonowana na wysokości oczu
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('game-container').appendChild(renderer.domElement);
      
      // PointerLockControls – kamera sterowana pierwszoosobowo
      controls = new THREE.PointerLockControls(camera, document.body);
      scene.add(controls.getObject());
      
      // Aktywacja blokady kursora po kliknięciu
      blocker.addEventListener('click', function() {
        controls.lock();
      }, false);
      
      controls.addEventListener('lock', function() {
        blocker.style.display = 'none';
      });
      
      controls.addEventListener('unlock', function() {
        blocker.style.display = 'flex';
      });
      
      // Dodaj światło
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5,10,7.5);
      scene.add(directionalLight);
      
      // Podłoże – prostokątna płaszczyzna (np. 100 x 50)
      const floorGeometry = new THREE.PlaneGeometry(100, 50);
      const floorMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);
      
      // Usunięto zielony kwadrat (beacon) oraz jego obsługę interakcji
      
      // Obsługa klawiszy do ruchu – ustawiamy eventy keydown/keyup
      document.addEventListener('keydown', function(e) {
        switch(e.code) {
          case 'KeyW': move.forward = true; break;
          case 'KeyS': move.backward = true; break;
          case 'KeyA': move.left = true; break;
          case 'KeyD': move.right = true; break;
          case 'ShiftLeft':
          case 'ShiftRight': sprint = true; break;
        }
      });
      document.addEventListener('keyup', function(e) {
        switch(e.code) {
          case 'KeyW': move.forward = false; break;
          case 'KeyS': move.backward = false; break;
          case 'KeyA': move.left = false; break;
          case 'KeyD': move.right = false; break;
          case 'ShiftLeft':
          case 'ShiftRight': sprint = false; break;
        }
      });
      
      window.addEventListener('resize', onWindowResize, false);
      animate();
    }
    
    // Aktualizacja rozmiaru renderera przy zmianie rozmiaru okna
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    let prevTime = performance.now();
    // Główna pętla animacji
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      
      // Jeśli pointer lock jest aktywny, obsłuż ruch
      if (controls.isLocked === true) {
        // Zerowanie prędkości (z oporem)
        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        
        // Ustalenie kierunku ruchu
        direction.z = Number(move.forward) - Number(move.backward);
        direction.x = Number(move.right) - Number(move.left);
        direction.normalize(); // aby nie przyspieszało przy diagonalnym ruchu
        
        // Obliczenie efektywnej prędkości
        const speed = baseSpeed * (sprint ? sprintMultiplier : 1);
        if (move.forward || move.backward) velocity.z -= direction.z * speed * delta;
        if (move.left || move.right) velocity.x -= direction.x * speed * delta;
        
        // Aktualizacja pozycji gracza – korzystamy z metod controls.move*
        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
      }
      
      prevTime = time;
      
      renderer.render(scene, camera);
    }
    
    // Uruchomienie gry
    initGame();
  </script>
</body>
</html>