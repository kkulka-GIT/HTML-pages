<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Block Dash Clone - Styl Stumble Guys</title>
  <!-- Dołączamy Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    /* Ustawienia ogólne – pełny ekran, brak marginesów */
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87ceeb;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    // Sprawdzamy, czy WebGL jest dostępny
    if ( !window.WebGLRenderingContext ) {
      alert("Twoje urządzenie nie obsługuje WebGL.");
    }

    // Główne zmienne sceny, kamery i renderera
    let scene, camera, renderer;
    // Obiekt gracza – czerwony sześcian
    let player;
    // Tablica platform (zielonych bloków)
    let platforms = [];
    // Sterowanie – przechowujemy stan klawiszy (lewo, prawo)
    let keys = { left: false, right: false };
    // Wektor prędkości gracza (z uwzględnieniem prędkości pionowej)
    let playerVelocity = new THREE.Vector3(0, 0, 0);

    // Parametry gry
    const GRAVITY = -30;        // przyspieszenie grawitacyjne
    const JUMP_VELOCITY = 12;    // początkowa prędkość skoku
    const FORWARD_SPEED = 10;    // automatyczna prędkość biegu (wzdłuż osi Z)
    const LATERAL_SPEED = 10;    // prędkość ruchu w lewo/prawo

    // Inicjalizacja i uruchomienie gry
    init();
    animate();

    function init() {
      // Utworzenie sceny i ustawienie tła
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);

      // Ustawienie kamery – parametr FOV pozostaje 75°
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      // Renderer – tworzymy, ustawiamy pixelRatio i clearColor
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x87ceeb, 1);
      document.body.appendChild(renderer.domElement);

      // Dodanie oświetlenia – ambient i directional
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7.5);
      scene.add(directionalLight);

      // Tworzymy gracza – czerwony sześcian o wymiarach 1x1x1
      const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
      const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      player = new THREE.Mesh(playerGeometry, playerMaterial);
      // Ustawiamy gracza tak, aby jego dolna krawędź była na poziomie y = 0 (startujemy z y = 1)
      player.position.set(0, 1, 0);
      scene.add(player);

      // Tworzymy platformy – zielone bloki
      // Każda platforma ma rozmiar 6x0.5x6; liczba platform ustawiona na 10
      const platformGeometry = new THREE.BoxGeometry(6, 0.5, 6);
      const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
      const numPlatforms = 10;
      for (let i = 0; i < numPlatforms; i++) {
        let platform = new THREE.Mesh(platformGeometry, platformMaterial.clone());
        // Platformy rozmieszczone są wzdłuż osi Z (co 8 jednostek), pozycja X jest losowa
        platform.position.set((Math.random() - 0.5) * 4, 0, -i * 8);
        // W userData zapisujemy parametry oscylacji: amplitudę, prędkość i przesunięcie fazowe
        platform.userData = {
          amplitude: Math.random() * 2 + 1,
          speed: Math.random() * 2 + 1,
          offset: Math.random() * Math.PI * 2
        };
        scene.add(platform);
        platforms.push(platform);
      }

      // Ustawienie obsługi klawiatury
      window.addEventListener('keydown', function(e) {
        if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
        if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
        // Skok – możliwy tylko, gdy gracz stoi na platformie
        if (e.code === "Space" && isPlayerOnPlatform()) {
          playerVelocity.y = JUMP_VELOCITY;
        }
      });
      window.addEventListener('keyup', function(e) {
        if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
        if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
      });

      // Obsługa zmiany rozmiaru okna
      window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // Funkcja sprawdzająca, czy gracz stoi na którejś z platform
    function isPlayerOnPlatform() {
      const tolerance = 0.2;
      for (let platform of platforms) {
        // Górna krawędź platformy: platform.position.y + (0.5 / 2) = platform.position.y + 0.25
        let platformTop = platform.position.y + 0.25;
        // Obliczamy odległość poziomą między graczem a platformą
        let dx = player.position.x - platform.position.x;
        let dz = player.position.z - platform.position.z;
        let horizontalDist = Math.sqrt(dx * dx + dz * dz);
        // Gracz "stoi" na platformie, jeśli:
        // - jego dolna krawędź (player.position.y - 0.5) jest blisko platformTop (różnica < tolerance)
        // - odległość pozioma jest mniejsza niż około 3.5 jednostki
        if (horizontalDist < 3.5 && Math.abs((player.position.y - 0.5) - platformTop) < tolerance) {
          return true;
        }
      }
      return false;
    }

    // Zmienna do śledzenia czasu poprzedniej klatki
    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      let currentTime = performance.now();
      let delta = (currentTime - lastTime) / 1000;
      lastTime = currentTime;

      // Aktualizacja ruchu platform – oscylują poziomo wg funkcji sinus
      platforms.forEach(platform => {
        const data = platform.userData;
        platform.position.x = data.amplitude * Math.sin(data.speed * currentTime / 1000 + data.offset);
      });

      // Gracz biegnie automatycznie do przodu (w dół osi Z)
      player.position.z -= FORWARD_SPEED * delta;

      // Ruch boczny gracza – sterowanie lewo/prawo
      if (keys.left) {
        player.position.x -= LATERAL_SPEED * delta;
      }
      if (keys.right) {
        player.position.x += LATERAL_SPEED * delta;
      }

      // Symulacja grawitacji – zwiększamy prędkość opadania
      playerVelocity.y += GRAVITY * delta;
      player.position.y += playerVelocity.y * delta;

      // Detekcja "lądowania" – sprawdzamy, czy gracz zbliża się do platformy
      platforms.forEach(platform => {
        let dx = player.position.x - platform.position.x;
        let dz = player.position.z - platform.position.z;
        let horizontalDist = Math.sqrt(dx * dx + dz * dz);
        let platformTop = platform.position.y + 0.25;
        // Jeśli gracz jest wystarczająco blisko platformy i jego ruch pionowy spowoduje przejście przez górną krawędź platformy:
        if (
          horizontalDist < 3.5 &&
          player.position.y - 0.5 > platformTop &&
          (player.position.y - 0.5 + playerVelocity.y * delta) <= platformTop + 0.1
        ) {
          player.position.y = platformTop + 0.5;
          playerVelocity.y = 0;
        }
      });

      // Jeśli gracz spadnie poniżej określonego poziomu, resetujemy grę
      if (player.position.y < -10) {
        resetGame();
      }

      // Uaktualniamy pozycję kamery – efekt trzecioosobowy: kamera za i nieco powyżej gracza
      let desiredCameraPos = new THREE.Vector3(
        player.position.x,
        player.position.y + 5,
        player.position.z + 10
      );
      camera.position.lerp(desiredCameraPos, 0.1);
      camera.lookAt(player.position);

      renderer.render(scene, camera);
    }

    // Funkcja resetująca gracza (np. po upadku)
    function resetGame() {
      player.position.set(0, 1, 0);
      playerVelocity.set(0, 0, 0);
    }
  </script>
</body>
</html>