<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>Block Dash Clone - Styl Stumble Guys</title>
  <!-- Dołączamy Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
  // Główne zmienne sceny, kamery i renderera
  let scene, camera, renderer;
  // Obiekt gracza
  let player;
  // Tablica platform
  let platforms = [];
  // Sterowanie – przechowujemy stan klawiszy (lewo, prawo)
  let keys = { left: false, right: false };
  // Wektor prędkości gracza (w tym pionowa składowa)
  let playerVelocity = new THREE.Vector3(0, 0, 0);
  
  // Stałe fizyczne
  const GRAVITY = -30;       // Przyspieszenie grawitacyjne
  const JUMP_VELOCITY = 12;  // Początkowa prędkość skoku
  const FORWARD_SPEED = 10;  // Automatyczna prędkość biegu do przodu
  const LATERAL_SPEED = 10;  // Prędkość poruszania się w lewo/prawo
  
  // Inicjalizacja sceny
  init();
  animate();
  
  function init() {
    // Tworzymy scenę i ustawiamy tło
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    
    // Kamera – ustawiamy szerokie pole widzenia, aby widzieć więcej (możesz modyfikować, jeśli chcesz)
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // Dodajemy oświetlenie
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);
    
    // Tworzymy gracza – czerwony sześcian
    const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
    const playerMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    player = new THREE.Mesh(playerGeometry, playerMaterial);
    // Ustawiamy gracza tak, aby „stał” na platformie (początkowo y = 1)
    player.position.set(0, 1, 0);
    scene.add(player);
    
    // Tworzymy platformy (zielone bloki)
    // Używamy jednej geometrii, a każda platforma ma indywidualne parametry ruchu
    const platformGeometry = new THREE.BoxGeometry(6, 0.5, 6);
    const platformMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
    const numPlatforms = 10;  // Liczba platform
    for (let i = 0; i < numPlatforms; i++) {
      let platform = new THREE.Mesh(platformGeometry, platformMaterial.clone());
      // Platformy ustawione są wzdłuż osi Z, z odstępem 8 jednostek
      // Początkowa pozycja X jest lekko losowa
      platform.position.set((Math.random() - 0.5) * 4, 0, -i * 8);
      // Zapisujemy w userData parametry ruchu: amplitudę, prędkość oscylacji oraz przesunięcie fazowe
      platform.userData = {
        amplitude: Math.random() * 2 + 1,
        speed: Math.random() * 2 + 1,
        offset: Math.random() * Math.PI * 2
      };
      scene.add(platform);
      platforms.push(platform);
    }
    
    // Ustawiamy obsługę klawiatury (lewo, prawo, skok)
    window.addEventListener('keydown', function(e) {
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
      // Skok – działa tylko, gdy gracz jest na platformie
      if (e.code === "Space" && isPlayerOnPlatform()) {
        playerVelocity.y = JUMP_VELOCITY;
      }
    });
    window.addEventListener('keyup', function(e) {
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
    });
    
    // Obsługa zmiany rozmiaru okna
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  }
  
  // Funkcja sprawdzająca, czy gracz stoi na którejś z platform (przyjmujemy tolerancję 0.2)
  function isPlayerOnPlatform() {
    const tolerance = 0.2;
    for (let platform of platforms) {
      // Platforma ma wysokość 0.5, więc jej górna krawędź to platform.position.y + 0.25
      let platformTop = platform.position.y + 0.25;
      // Przyjmujemy, że gracz „stoi” na platformie, jeśli jego dolna krawędź (player.position.y - 0.5)
      // znajduje się blisko platformTop oraz gracz jest w obrębie platformy (odległość pozioma mniejsza niż ~3.5)
      let dx = player.position.x - platform.position.x;
      let dz = player.position.z - platform.position.z;
      let horizontalDist = Math.sqrt(dx * dx + dz * dz);
      if (horizontalDist < 3.5 && Math.abs((player.position.y - 0.5) - platformTop) < tolerance) {
        return true;
      }
    }
    return false;
  }
  
  let lastTime = performance.now();
  function animate() {
    requestAnimationFrame(animate);
    let currentTime = performance.now();
    let delta = (currentTime - lastTime) / 1000;
    lastTime = currentTime;
    
    // Aktualizacja ruchu platform – poruszają się poziomo wg funkcji sinus
    platforms.forEach(platform => {
      const data = platform.userData;
      platform.position.x = data.amplitude * Math.sin(data.speed * currentTime / 1000 + data.offset);
    });
    
    // Gracz biegnie automatycznie do przodu (w dół osi Z)
    player.position.z -= FORWARD_SPEED * delta;
    
    // Obsługa ruchu bocznego – sterowanie klawiszami A/D lub strzałkami
    if (keys.left) {
      player.position.x -= LATERAL_SPEED * delta;
    }
    if (keys.right) {
      player.position.x += LATERAL_SPEED * delta;
    }
    
    // Symulacja grawitacji oraz skoku
    playerVelocity.y += GRAVITY * delta;
    player.position.y += playerVelocity.y * delta;
    
    // Prosta detekcja kolizji z platformami – jeśli gracz spada na platformę, ustawiamy go na jej powierzchni
    platforms.forEach(platform => {
      let dx = player.position.x - platform.position.x;
      let dz = player.position.z - platform.position.z;
      let horizontalDist = Math.sqrt(dx * dx + dz * dz);
      let platformTop = platform.position.y + 0.25;
      // Jeśli gracz jest wystarczająco blisko platformy i przechodzi przez jej górną krawędź, "lądujemy"
      if (horizontalDist < 3.5 &&
          player.position.y - 0.5 > platformTop &&
          (player.position.y - 0.5 + playerVelocity.y * delta) <= platformTop + 0.1) {
        player.position.y = platformTop + 0.5;
        playerVelocity.y = 0;
      }
    });
    
    // Jeśli gracz spadnie poniżej pewnego poziomu, resetujemy grę
    if (player.position.y < -10) {
      resetGame();
    }
    
    // Uaktualniamy kamerę – ustawiamy ją za i nieco powyżej gracza
    let desiredCameraPos = new THREE.Vector3(player.position.x, player.position.y + 5, player.position.z + 10);
    camera.position.lerp(desiredCameraPos, 0.1);
    camera.lookAt(player.position);
    
    renderer.render(scene, camera);
  }
  
  // Funkcja resetująca gracza (np. po upadku)
  function resetGame() {
    player.position.set(0, 1, 0);
    playerVelocity.set(0, 0, 0);
  }
</script>
</body>
</html>